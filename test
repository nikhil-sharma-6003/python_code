def normalize_single_cell_table_lines(page_df, tol_ratio=0.03):
    """
    SAFE VERSION:
    - Only normalize true data continuation rows
    - Skip headers / titles / section rows
    - Prevent table fragmentation
    """

    import pandas as pd
    import re

    page_df = page_df.sort_values(["line_no", "x0"]).copy()

    line_counts = page_df.groupby("line_no").size()

    table_lines = set(
        page_df.loc[page_df["comment"] == "This is a table", "line_no"]
    )

    if not table_lines:
        return page_df

    # reference line (max columns)
    ref_line = max(table_lines, key=lambda ln: line_counts.get(ln, 0))
    ref_rows = (
        page_df[page_df["line_no"] == ref_line]
        .sort_values("x0")
        .reset_index(drop=True)
    )

    reference_boxes = ref_rows[["x0", "x1", "y0", "y1"]].values.tolist()

    new_rows = []

    # -----------------------------
    # helper: detect header-like row
    # -----------------------------
    def is_header_like(text):
        text = str(text).strip()

        if not text:
            return True

        # year only
        if re.fullmatch(r"\d{4}", text):
            return True

        # mostly uppercase (e.g., TOTAL, YEAR ENDED)
        if text.isupper():
            return True

        # long descriptive sentence
        if len(text.split()) > 6:
            return True

        # contains header keywords
        header_keywords = [
            "year", "quarter", "total",
            "change", "thereafter", "securitization"
        ]
        if any(k in text.lower() for k in header_keywords):
            return True

        return False

    # -----------------------------
    # iterate lines
    # -----------------------------
    for line_no in page_df["line_no"].unique():

        # must be single-cell
        if line_counts.get(line_no, 0) != 1:
            continue

        # must be inside table block (not just near)
        if line_no not in table_lines:
            continue

        base_idx = page_df.index[page_df["line_no"] == line_no][0]
        base_row = page_df.loc[base_idx]

        text = base_row["text"]

        # skip header-like rows
        if is_header_like(text):
            continue

        mx0 = float(base_row["x0"])

        matched_col_idx = None
        best_dist = float("inf")

        # left-edge matching only
        for j, (rx0, rx1, ry0, ry1) in enumerate(reference_boxes):

            col_width = max(rx1 - rx0, 1e-6)
            threshold = tol_ratio * col_width

            dist = abs(mx0 - rx0)

            if dist <= threshold and dist < best_dist:
                best_dist = dist
                matched_col_idx = j

        if matched_col_idx is None:
            continue

        # align base row
        rx0, rx1, ry0, ry1 = reference_boxes[matched_col_idx]

        page_df.loc[base_idx, ["x0", "x1", "y0", "y1"]] = [rx0, rx1, ry0, ry1]
        page_df.loc[base_idx, "comment"] = "This is a table"

        # add empty cells for other columns
        for j, (rx0, rx1, ry0, ry1) in enumerate(reference_boxes):
            if j == matched_col_idx:
                continue

            new_rows.append({
                "page_num": base_row["page_num"],
                "line_no": line_no,
                "text": "",
                "x0": rx0,
                "x1": rx1,
                "y0": ry0,
                "y1": ry1,
                "comment": "This is a table"
            })

    if new_rows:
        page_df = pd.concat([page_df, pd.DataFrame(new_rows)], ignore_index=True)
        page_df = page_df.sort_values(["line_no", "x0"]).reset_index(drop=True)

    return page_df
